#!/usr/bin/env node
/** -------------------------------------------------------------------------------------------------------------------
 * lib.js
 */

/**
 * get(path)
 *  获取指定路径的文本数据
 */
var get = function(fs){
  if(this.window) {
    fs = new XMLHttpRequest;
    return function(path){
      fs.open('GET', path, false);
      fs.send();
      if(!(fs.status / 100 ^ 2))
        return fs.responseText;
    }
  }
  else {
    fs = require('fs');
    return function(path) {
      return fs.readFileSync(path).toString();
    }
  }
}();

/**
 * repath(path, rel)
 *  计算相对路径
 */
var repath = function(path, rel){
  var rePath = /^(https?:\/\/[\w-.]+(?::\d+)?|)([\w\/.-]+)(.*|)/;
  var reRel = /^(https?:\/\/[\w-.]+(?::\d+)?|)(\/(?:[\w.-]+\/)*)/;

  function repath(path, rel) {
    var ms = path.match(rePath);
    if (ms && !ms[1] && rel && (rel = rel.match(reRel))) {
      path = ms[2];
      if (path[0] !== '/') {
        path = rel[2] + path;
      }
      path = rel[1] + normalize(path) + ms[3];
    }
    return path;
  }

  /** normalize(path) 路径规格化 */
  var reSlash = /\/+/;

  function normalize(src) {
    var des = [];
    src = src.split(reSlash);
    for (var i = 0, l = src.length; i < l; i++) {
      var sym = src[i];
      if (des.length) {
        if (sym !== '.') {
          var end = des[des.length - 1];
          if (sym !== '..') {
            if (end === '.' && sym) des.length--;
            des.push(sym);
          }
          else if (end === '..') {
            des.push(sym);
          }
          else if (end) {
            des.length--;
          }
        }
      }
      else {
        des.push(sym);
      }
    }
    return des.join('/');
  }

  return repath;

}();

/** -------------------------------------------------------------------------------------------------------------------
 * lex.js
 */

var lex = function () {
  function $() { return arguments };

  function regular(any, keys) {
    if (any instanceof Object) {
      if (any instanceof RegExp) {
        any = any.source;
      }
      else if (any.length) {
        var arg = [];
        for (var i = 0; i < any.length; i++)
          arg[i] = regular(any[i], keys);
        // any = arg.join(any.join ? '' : '|');
        if (any.join) {
          any = arg.join('');
        }
        else {
          any = arg.join('|');
          if (arg.length > 1)
            any = '(?:' + any + ')';
        }
      }
      else {
        arg = String(Object.keys(any));
        keys[arg] = keys.$ = (keys.$ | 0) + 1;
        any = '(' + regular(any[arg], keys) + ')';
      }
    }
    else {
      any = String(any);
    }
    return any;
  }

  var keys = Object.create(null);
  var lex = regular($(
    { INCLUDE: [/\/\/#include\s+/, { FILE: /\S+/ }, /.*/] },
    { DEFINE: [/\/\/#define\s+/, { DID: /[a-zA-Z_$][\w$]*/ }, /\s*/, $([/@\s*/, { RES: /\S+/ }, /.*/], [/=\s*/, { EXP: /.+/ }], { VAL: /.+/ })] },
    { VAR: [/\/\/#var\s+/, { VID: /[a-zA-Z_$][\w$]*/ }, /\s*=\s*/, { VEXP: /.+/ }] },
    { BLOCK_HEAD: /\{/ },
    { BLOCK_TAIL: /\}/ },
    { ARG_HEAD: /\(/ },
    { ARG_TAIL: /\)/ },
    { ID: /[a-zA-Z_$][\w$]*/ },
    { STRING: /'(?:[^'\n\\]|\\[^])*(?:['\n]|$)|"(?:[^"\n\\]|\\[^])*(?:["\n]|$)|`(?:[^`\\]|\\[^])*(?:`|$)/ },
    { REGEXP: /\/(?:\\.|\[(?:\\.|[^\]])*\]|[^\/\*\n\r])(?:\\.|\[(?:\\.|[^\]])*\]|[^/\n\r])*?\/[gimy]*/ },
    { COMMENT: /\/\/.*|\/\*[^*]*\*+(?:[^/][^*]*\*+)*\// },
    { OTHER: /(?:[^{}()a-zA-Z_$'"`/]|\/(?![/*]))+/ },
    { SPECIAL: /\// }
  ), keys);

  lex = RegExp(lex + '|', 'g');
  lex.$ = keys;

  return lex;
}();

/** -------------------------------------------------------------------------------------------------------------------
 * make.js
 */

/**
 * make(path, rel)
 */
var make = function (calc) {
  function make(path, rel) {
    return makeFile(path, rel, Object.create(null), Object.create(null), Object.create(null), "");
  }

  function makeFile(path, rel, includes, defines, variables, indent) {
    var code;
    path = repath(path, rel);
    if (includes[path]) {
      code = '';
    }
    else {
      includes[path] = 1;    // 占位符，防止无限递归
      code = get(path);
      if (code)
        try {
          code = makeCode(code, path, includes, defines, variables, indent);
        }
        catch (e) {
          if (e instanceof MacroError)
            e = Error(e.message + ' at (' + path + ':' + rowcol(code, e.index) + ')');
          throw e;
        }
    }
    return code;
  }

  function makeCode(code, rel, includes, defines, variables, indent) {
    var re = new RegExp(lex), $ = lex.$, token, codes = [], id, it;
    while (token = re.exec(code)) {
      var s = token[0];
      if (!s) {
        if (token.index < code.length)
          throw new MacroError('Unknown token', token.index);
        break;
      }

      if (token[$.INCLUDE]) {
        var file = token[$.FILE];
        if (file = makeFile(file, rel, includes, defines, variables, indent + indentOf(code, token.index)))
          s = file;
      }
      else if (token[$.DEFINE]) {
        id = token[$.DID];
        if (it = token[$.VAL]) {
          it = it.trim();
        }
        else if (it = token[$.RES]) {
          it = repath(it, rel);
          try {
            s = get(it);
            if (s === undefined)
              throw Error("Read file error: " + it);
          }
          catch (e) {
            throw new MacroError(e.message, token.index);
          }
          it = JSON.stringify(s);
        }
        else if (it = token[$.EXP]) {
          it = calc(variables, it);
        }
        defines[id] = variables[id] = it;
        s = "//const "+id+" = "+String(it);
      }
      else if(token[$.VAR]) {
        id = token[$.VID];
        it = token[$.VEXP];
        it = calc(variables, it);
        variables[id] = it;
        s = "//var "+id+" = "+String(it);
      }
      else if (id = token[$.ID]) {
        if (id in defines) {
          s ="/*" + id + "*/" + String(defines[id]);
        }
      }
      else if (token[$.BLOCK_HEAD] || token[$.ARG_HEAD]) {
        defines = Object.create(defines);
      }
      else if (token[$.BLOCK_TAIL] || token[$.ARG_TAIL]) {
        var proto = Object.getPrototypeOf(defines);
        if (proto) defines = proto;
      }
      codes[codes.length] = s;
    }
    code = codes.join('');
    code = code.replace(/^/gm, indent).slice(indent.length);
    return code;
  }

  function MacroError(message, index) {
    this.message = message;
    this.index = index;
  }

  function indentOf(text, index) {
    for (var i = index; ' \t'.indexOf(text[i - 1]) >= 0; i--);
    return text.slice(i, index);
  }

  /**
   * rowcol(text, i)
   *   计算文本 text 位置 i 的行列值。返回格式 "row:col"
   */
  function rowcol(text, index) {
    if (index < 0) return '<EOF>';
    var reLn = /[\n\u2028\u2029]|\r\n?/g;
    var row = 0, col = 0;
    while (reLn.exec(text) && index > reLn.lastIndex) {
      row++;
      col = reLn.lastIndex;
    }
    col = index - col;
    return (row + 1) + ':' + (col + 1);
  }

  return make;
}((global||window).eval("(function(){with(arguments[0])return eval(arguments[1])})"));

/** -------------------------------------------------------------------------------------------------------------------
 * mjc.js
 *  命令行编译工具 mjc
 */

(function () {
  try {
    var home = process.cwd() + "/";
    var argv = process.argv.slice(2);
    if (argv.length < 2) {
      console.log('Macro JavaScript Complier (0.0.9)\n  Usage: mjc <input> <output>');
    }
    else {
      var code = make(argv[0], home);
      if (code === undefined) {
        console.error('Can not read from file: ' + argv[0]);
      }
      else {
        var fs = require('fs');
        fs.writeFileSync(argv[1], code);
      }
    }
    process.exit(0);
  }
  catch (e) {
    console.error(e.message);
    process.exit(1);
  }
})();

